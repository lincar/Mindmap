<HTML><HEAD><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><style type="text/css">body {font-family: arial,sans-serif; font-size: 14pt; font-weight: normal; color: #000000;}h1 {font-size: 28pt; font-weight: bold;}h2 {font-size: 20pt; font-weight: bold;}.note {font-size: 10pt; font-weight: normal; font-style: italic; color:gray;}</style><title>iThoughts</title></HEAD><BODY><div style="font-family: arial,sans-serif; font-size: 14pt; font-weight: normal; color: #000000;"><ul><li>SpringMvc<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Spring Web MVC<br/>${pageContext.request.contextPath} 上下文路径直接到WebRoot</span></li><ul><li>HandleMapping<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>有默认的处理方式（1次配置好）</span></li><ul><li>BeanNameUrlHandlerMapping<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>默认就在配置这个</span></li><ul><li>映射：&lt;bean id=&quot;BeanNameUrlHandlerMapping&quot; class=&quot;…&quot;/&gt;<br/>控制器:&lt;bean name=&quot;Rico.action&quot; class=&quot;…controller&quot;/&gt;<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>第二个Class里的controller是自己写的那个类</span></li></ul><li>SimpleUrlHandlerMapping<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>用于多个URL对应同一个controller</span></li><ul><li>映射：&lt;bean id=&quot;simpleUrlHandleMapping&quot; class=&quot;…&quot;&gt;<br/>  &lt;property name=&quot;mapping&quot;&gt;<br/>      &lt;props&gt;<br/>      &lt;prop key=&quot;vino.action&quot;&gt;homeController&lt;/props&gt;<br/>      &lt;prop key=&quot;am.action&quot;&gt;homeController&lt;/props&gt;<br/>      &lt;prop key=&quot;hi.action&quot;&gt;homeController&lt;/props&gt;<br/>      &lt;/props&gt;<br/>  &lt;property&gt;<br/>&lt;/bean&gt;<br/><br/>控制器:&lt;bean id=&quot;homeController&quot; class=&quot;…Controller&quot;/&gt;<br/></li></ul><li>ControllerClassNameHandlerMapping<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>用于类名URL访问（小写）</span></li><ul><li>映射：&lt;bean id=&quot;controllerClassNameHandlerMapping&quot; class=&quot;…&quot;/&gt;<br/></li></ul><li>自动扫描：<br/>&lt;context:component-scan base-package=&quot;XXX.web.controller&quot;/&gt;<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>base-package:扫描的路径是在src下控制器文件夹下的文件夹路径，例如：opkm.pw.项目.web.controller</span></li><li>注解驱动：<br/>&lt;mvc:annotation-driven/&gt;<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>注解减少对XML的配置，程序通过注解传递参数，jsp页面传递参数都放在注解中，注解根据页面触发的不同事件决定controller执行哪个方法</span></li></ul><li>Controller<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>1.调用注解相关的*action<br/><br/>2.导出与值相关的对象（导出的方法在业务层service里实现）<br/><br/>3.📦对象（Model来穿出去）</span></li><li>DispatcherServlet<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>配置1次搞定,分发过滤拦截</span></li><ul><li>web.xml<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>配置文件，在WEB-INF文件夹根下</span></li><ul><li>配置Servlet</li><ul><li>&lt;servlet&gt;<br/>  &lt;servlet-name&gt;action&lt;/servlet-name&gt;<br/>  &lt;servlet-class&gt;…&lt;/servlet-name&gt;<br/>&lt;/servlet&gt;<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Dispatcher的类</span></li></ul><li>配置Servlet映射</li><ul><li>&lt;servlet-mapping&gt;<br/>  &lt;servlet-name&gt;action&lt;/servlet-name&gt;<br/>  &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;<br/>&lt;servlet-mapping&gt;</li></ul><li>配置XML位置</li><ul><li>  &lt;init-param&gt;<br/>     &lt;param-name&gt;contextConfigLocation&lt;param-name&gt;<br/>     &lt;param-value&gt;classpath:XXX.xml&lt;param-name&gt;<br/>  &lt;/init-param&gt;<br/>  &lt;load-on-startup&gt;1&lt;load-on-startup&gt;<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>项目文件位置</span></li><li>&lt;context-param&gt;<br/>   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br/>   &lt;param-value&gt;classpath:beans.xml&lt;/param-value&gt;<br/>&lt;/context-param&gt;<br/>&lt;listener&gt;<br/>   &lt;listener-class&gt;…ContextLoaderListener&lt;/listener-class&gt;<br/>&lt;/listener&gt;</li></ul></ul></ul><li>ViewAndModel<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Model对象：📦我们的数据，传递给view<br/>转向ViewResolver（试图解释器）</span></li><li>XXX.xml<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>项目名.xml<br/><br/>格式文件<br/><br/>HandlerMapping自动扫描：扫描逻辑层的Controller文件夹<br/><br/>注解驱动<br/><br/>内部资源视图解释器<br/><br/>资源管理  &lt;mvc:resources location=&quot;/resources/&quot; mapping=&quot;/resources/**&quot;/&gt;     （在根目录下创建resources文件夹）</span></li><li>框架层/注解<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>@Controller @Service @Repository @Component <br/>这四个注解效果一样，Spring都会把他们当作需要注入的Bean加载在上下文中</span></li><ul><li>访问控制层@Controller</li><ul><li>@RequestMapping<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>在方法或者类上面一行写：<br/>@RequestMapping(&quot;home.action&quot;)<br/>@RequestMapping(value={ &quot;/&quot;, &quot;/home.action&quot; } )<br/>@RequestMapping(value={&quot;/…&quot;}, method={RequestMethod.Get})                   默认指定方式<br/></span></li><ul><li>@RequestParam<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>在view和Controller之间参数传递中映射：<br/><br/>@RequestParam(&quot;deleteID&quot;) Integer id <br/>@RequestParam(&quot;photo&quot;) MutipartFile file </span></li><li>@PathVariable<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>@RequestMapping(value=&quot;/comment/{blogId}&quot;, method=RequestMethod.POST)  <br/><br/>public void comment(Comment comment,@PathVariable(&quot;blogId&quot;) int id, HttpSession session, HttpServletResponse response) throws IOException {  </span></li></ul><li>@Resource</li></ul><li>数据访问层DAO<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>📦对数据库的访问，查询数据（对数据持久话），不包含任何业务逻辑（简单的CRUD包括）<br/><br/>里面具有N个DAO，并且每个DAO对应</span></li><li>业务层@Service<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>对数据的预处理，便于业务变化，改动代价小<br/><br/>调用一个或多个DAO的功能点来组合业务逻辑（CRUD的简单操作称为功能点）<br/>（被注入多个DAO对象，以完成其数据操作）（也叫事务管理）<br/><br/>service模块的数量应该由功能模块定义</span></li></ul><li>Beans.xml<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Beans.xml：<br/><br/>格式文件<br/><br/>自动扫描：扫描业务层的Service文件夹<br/></span></li><li>ViewResolver<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>1次配置好</span></li><ul><li>内部资源视图解释器</li><ul><li>&lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;…&quot;&gt;<br/>  &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsps/&quot;/&gt;<br/>  &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;<br/>&lt;/bean&gt;</li></ul></ul><li>View<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Taglib<br/>1.页面的设计 （什么功能的页面）<br/><br/>2.把对象传进去（增/改后的保存）<br/><br/>3.把对象或值通过链接方式传出action。    （ &lt;a href=“${pageContext.request.contextPath}/…action?id=…&quot;&gt;…&lt;/a&gt; ）</span></li><ul><li>Get</li><li>Post<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>需要在taglib中声明post（method) <br/><br/>如果还有其他对象要传出，需要声明（例如：modelAttribute)</span></li><ul><li>&lt;a href…</li></ul></ul><li>持久层</li><ul><li>校验<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>校验在view页面只能使用springmvc的标签。<br/>1.在PO对象中设置<br/>2.在view中设置如何显示错误<br/>3.在控制类中设置@Valid和传入的BindingResult错误处理</span></li><ul><li>@Size<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>@Size(min=3, max=10, message=&quot;…&quot;)<br/></span></li><li>@NotNuLL<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>@NotNuLL(message=&quot;&quot;)</span></li><li>@Valid<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>要校验的对象<br/>@Valid<br/><br/>BindingResult来处理校验错误信息</span></li></ul></ul><li>?<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>classpath<br/>Context-param<br/>listener<br/>pageContext.request.contextPath<br/>taglib<br/>Form<br/>Model<br/>Input age</span></li><li>&lt;property name=&quot;order&quot; value=&quot;2&quot;/&gt;</li><li>Request</li><li>POJO纯对象/Entity<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>用作传输过程称为DTO</span></li><li>VO对象<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>可以和表对应，也可以不。<br/><br/>一个VO由多个PO组成，也可以通过VO的Getter和Setter访问实际PO的值。</span></li><li>持久对象PO<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>一个PO对应一个数据库的column（列，字段），用hibernate生成是不错的选择。（完全透明）</span></li><li>Hibernate</li><li>Database <span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Entity</span></li><li>Request</li><li>将该类定义一个Bean</li><li>注解@</li><ul><li>@Repository<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>只能注解在DAO实现类上（用于Service实现类里的💉）<br/><br/></span></li><li>@Service<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>只能注解在Service的实现类上（用于controller里的💉）<br/><br/>把DAO实现类💉到Service实现类中的对象</span></li><li>@Controller<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>只能注解在controller实现类上<br/><br/>把Service接口的实现类💉到Controller类里的对象</span></li><li>@Component<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>@Component 通过注释定义 Bean，从传统的 XML 配置文件中完全移除 Bean 定义的配置</span></li><li>@RequestMapping<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>在方法或者类上面一行写：<br/>@RequestMapping(&quot;home.action&quot;)<br/>@RequestMapping(value={ &quot;/&quot;, &quot;/home.action&quot; } )<br/>@RequestMapping(value={&quot;/…&quot;}, method={RequestMethod.Get})                   默认指定方式<br/></span></li><ul><li>@RequestParam<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>在view和Controller之间参数传递中映射：<br/><br/>@RequestParam(&quot;deleteID&quot;) Integer id <br/>@RequestParam(&quot;photo&quot;) MutipartFile file </span></li><li>@PathVariable<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>@RequestMapping(value=&quot;/comment/{blogId}&quot;, method=RequestMethod.POST)  <br/><br/>public void comment(Comment comment,@PathVariable(&quot;blogId&quot;) int id, HttpSession session, HttpServletResponse response) throws IOException {  </span></li></ul><li>@Resource<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>&lt;bean   class=&quot;org.springframework.context.annotation.CommonAnnotationBeanPostProcessor&quot;/&gt;<br/>@Resource装配顺序<br/>　　1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常<br/>　　2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常<br/>　　3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常<br/>　　4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； <br/><br/>@Resources按名字，是ＪＤＫ的，@Autowired按类型，是Ｓｐｒｉｎｇ的<br/><br/></span></li><ul><li>name</li></ul><li>@Autowired<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>&lt;bean class=&quot;org.springframework.beans.factory.annotation. AutowiredAnnotationBeanPostProcessor&quot;/&gt; <br/><br/>@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作<br/><br/>@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。</span></li><ul><li>@Qualifier<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>@Autowired  <br/>public void setOffice(@Qualifier(&quot;office&quot;)Office office) {   <br/>      this.office = office;<br/> } <br/><br/></span></li><li>@required</li></ul><li>@Inject<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>JSR-330注解</span></li><li>@Name<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>指定Bean的名字</span></li><li>@Transactional<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>需要进行事务管理</span></li><li>@SuppressWarnings<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>取消显示指定的编译器警告</span></li><li>@Deprecated<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>用于所有元素，说明该方法或属性等都已过时，不建议使用，编译器会产生⚠信息（它很危险，或者存在更好的选择）</span></li><li>@Override<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>用在实现接口类中的方法（用于给编译器验证你的方法是否是继承的方法，还有是否全部实现接口的方法）</span></li></ul><li>💉</li><li>XML</li><li>导入JAR包/Maven,配置web.xml</li><li>创建工程</li><li>新建DAO文件夹</li><li>Domain文件下配置POJO对象</li><li>DAO文件下建立 接口<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>接口编写简单的CRUD功能点抽象方法</span></li><li>DAO文件下建立对应的 实现类<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>实现相应的接口<br/><br/>创建private SessionFactory session 对象（初始化Hiberater）（一个项目只需要一个SessionFactory就够了，一个数据库对应一个）<br/><br/>session.getCurrentSession.函数名</span></li><li>在src下建立test文件下<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>测试service业务<br/><br/>初始化（ApplicationContext得到beans）</span></li><li>新建Service文件夹</li><li>Domain文件下配置映射文件”项目.hbm.xml”<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>注意主健配置</span></li><li>src下配置项目.servlet.xml<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>格式配置<br/><br/>自动扫描（Controller)<br/><br/>注解驱动<br/><br/>视图解释器<br/><br/>资源管理</span></li><li>Service文件下建立 接口<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>具体业务方法接口</span></li><li>Service文件下建立对应的 实现类</li><li>src下配置beans.xml<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>格式配置<br/><br/>自动扫描（service, DAO)<br/><br/>分散配置（jdbc.properties)<br/><br/>数据源（名称与hibernate配置名称不同）<br/><br/>本地会话工程，spring和hibernate 的和谐（sessionFavtory和映射文件）<br/><br/>事务（事务管理器和事务通知）</span></li><li>src下配置数据源，配置jdbc.properties文件<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>连接数据库和编码<br/><br/>用户名和秘密<br/><br/>基础配置<br/><br/>hibernate的配置</span></li><li>创建项目，编写数据库表</li><li>进入数据库</li><li>Test</li><li>Service</li><li>DAO</li><li>Domain</li><li>src</li></ul></ul></div></BODY></HTML>