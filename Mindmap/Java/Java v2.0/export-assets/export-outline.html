<HTML><HEAD><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><style type="text/css">body {font-family: arial,sans-serif; font-size: 14pt; font-weight: normal; color: #000000;}h1 {font-size: 28pt; font-weight: bold;}h2 {font-size: 20pt; font-weight: bold;}.note {font-size: 10pt; font-weight: normal; font-style: italic; color:gray;}</style><title>iThoughts</title></HEAD><BODY><div style="font-family: arial,sans-serif; font-size: 14pt; font-weight: normal; color: #000000;"><ul><li>Java v2.0</li><ul><li>数组<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>静态：数组初始化后（引用对象后），数组长度是确定的，不能修改。</span></li><ul><li>引用变量</li><ul><li>栈<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>eg. main {<br/>变量都在不同的不同的栈区（取决于你的域）<br/>}</span></li></ul><li>数组对象</li><ul><li>堆<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>只能通过引用变量访问堆里面的对象<br/><br/>在堆中，1维数组第一次初始化后值为null的类型是int，int再次初始化的值后为0，所以只能有二维数组，而不能有多维数组。（java是强类型）</span></li></ul></ul><li>变量</li><ul><li>成员变量<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>创建对象都会为所有的实例变量创建内存，并且赋予初始值（0，null），之后再由构造器初始化具体值</span></li><ul><li>堆<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>实例对象一旦创建，堆就分出一段内存块供给使用</span></li><li>final<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>宏变量意味着编译器时就被确定（变成一个具体值引用）<br/><br/>如果初始化采用了 方法 或者在 静态块中 定义的话就不会替换成宏变量</span></li><ul><li>直接初始化一个具体的值</li></ul><li>static<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>又称 静态变量/类变量<br/><br/>只要该类初始化后，类变量将最先初始化，并且在类块中分配一段内存（以后都不变）<br/><br/>所以无论如何创建出来的 实例对象 访问static都是底层转换为 原类访问<br/><br/></span></li><ul><li>所有实例对象都可以访问</li></ul><li>实例变量<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>实例变量在类的创建对象实例时创建内存<br/><br/>或者非静态初始化块内初始化时创建内存<br/><br/>或者构造器初始化时创建内存</span></li></ul><li>局部变量</li><ul><li>栈</li></ul></ul><li>this<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>this指的是当前的初始化的类<br/><br/>如果父类有this，那么继承的子类在初始化对象时候，this是指向子类。因为父类的构造器在子类的构造器里面运行，但是this虽代表子类，但位置在父类构造器里面，所以输出类型是父类<br/><br/>所以父类子类都有this，会造成父类重写子类的情况，要解决这个问题，必须避免父类，子类构造器都有this</span></li><li>继承<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>对于一个 引用变量 而言，当通过该 引用变量 来访问它所引用的对象的 实例变量 时，该 实例变量 的值取决于 引用变量的类型；<br/><br/>当通过该 引用变量 来访问它所引用的对象的 方法 时，该 方法 行为取决于 实际引用对象 的值；</span></li><ul><li>成员变量</li><ul><li>子类和父类在继承的时候都保持同名的实例变量<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>一个子类在堆中的内存包含了父类的所有实例变量（同名不会覆盖），可以用supper调用</span></li></ul><li>方法</li><ul><li>父类将会把方法转移到子类中（如果没有重写）</li></ul><li>堆<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>jvm会为所有的父类和子类实例变量创建空间，子类每创建一个实例就会就会创建一堆的实例变量</span></li></ul><li>集合</li><ul><li>Set</li><ul><li>HashSet<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>由hashmap实现，其中源代码中hashmap的value由默认值代替。如果key为类的对象，必须重写hashcode()，和equals()函数，可选择的toString()!!</span></li><li>TreeSet<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>由TreeMap来实现。红黑树来实现来保存集合的Entry，实现快速定位和查找。</span></li></ul><li>Map</li><ul><li>HashMap<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>数据链路的方式储存。<br/>根据hash(key)来确定储存位置。</span></li><ul><li>Entry</li><ul><li>Key<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>把某个 类的对象 当作key，必须重写hashcode()，和equals()函数，可选择的toString()<br/><br/>把 String 当作key，不需要重写hashcode()，和equals()函数</span></li><ul><li>hashcode()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>由key.hashcode()来确定hash表的位置</span></li><li>equals()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>equals()确定是否覆盖还是产生链<br/>true：覆盖<br/>false：链</span></li></ul><li>Value</li></ul></ul><li>TreeMap</li></ul><li>List</li><ul><li>ArrayList<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>顺序储存的线性表。添加数据和删除数据都很慢，因为都要数据都要“整体搬家”。查询快<br/><br/>添加的元素大于底层封装的数组长度，ArrayList会创建一个原来数组1.5倍的数组</span></li><ul><li>添加数据</li><li>不是经常删除数据</li></ul><li>Vector<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>比起ArrayList，唯一好处它是线程安全。即使如此，多线程编程也可以把ArrayList包装成线程安装的集合类。</span></li><ul><li>多线程安全才用</li></ul><li>LinkedList <span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>双向链表。添加和删除都很方便，但是按照索引找到相应的索引值就要一个一个找（链表就是这样）<br/><br/>如果程序需要总是添加（指定位置）和删除，可以考虑用这个</span></li><ul><li>经常添加和删除数据</li></ul></ul><li>Iterator<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>迭代器接口，具体怎么实现都由各个集合去写</span></li><ul><li>遍历的时候不能删除</li></ul></ul><li>Jvm♻️<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>System.gc()<br/>System.runFinalization()</span></li><ul><li>内存泄漏<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>尤其是自己设计一个数组的数据结构，如果要删除数组中的数据必须把无用的内存♻️（回收）回来。</span></li><ul><li>常见</li><ul><li>字符串直接量多次赋值<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>字符串池泄漏</span></li><li>自定义数组进行删除</li></ul></ul><li>引用<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>一个main代表一个线程。<br/><br/>引用变量和对象就像有向图的顶点，引用关系为有向图的边。所有对象都是一条一条线程创建出来，如果顶点为不可到达，jvm就会♻️（回收）</span></li><ul><li>强引用<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>无论内存紧不紧张，内存都不会♻️（回收）</span></li><li>软引用<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>内存紧张，内存自动♻️（回收）</span></li><ul><li>SoftReference()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>SoftReference&lt;Person&gt;[] people = new SoftReference[100];<br/>for (int i = 0; i &lt; people.length; i++){<br/>    people[i] = new SoftReference&lt;Person&gt;(new people(&quot;zhenchao&quot;, &quot;zhan&quot;)); <br/>}<br/>System.out.println(people[0].get());</span></li></ul><li>弱引用<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>弱引用只要垃圾回收机制一运行都会进行被♻️（回收），所以要注意：弱引用的对象可能是null（这样的话就需要重新创建该对象）</span></li><ul><li>WeakReference()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>一般很少用WeakReference()，更多的是使用WeakHashMap()。<br/><br/>//创建一个字符串字符<br/>String str = new String(&quot;hello, rico&quot;);<br/>//创建一个弱引用，并且引用到str<br/>WeakReference&lt;String&gt; wrReference = new WeakReference&lt;String&gt;(str);<br/>//切断str引用<br/>str = null;<br/>//取出弱引用所引用的内容<br/>System.out.println(wrReference.get());<br/>//强制垃圾回收<br/>System.gc();<br/>System.runFinalization();<br/>//取出弱引用所引用的内容<br/>System.out.println(wrReference.get());</span></li><ul><li>WeakHashMap<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>使用WeakHashMap()必须重写hashcode()，和equals()</span></li></ul></ul><li>虚引用<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>跟踪对象被垃圾回收的状态</span></li></ul><li>内存管理小技巧</li><ul><li>避免在经常调用的方法，循环内创建对象<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>是 经常</span></li><li>使用StringBuilder和StringBuffer进行字符串连接和删除<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>对于字符本身需要频繁操作（例如数据库的链接）</span></li><ul><li>StringBuilder<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>在单线程的使用下，优先使用这个。</span></li><li>StringBuffer<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>已过时，但是StringBuffer是线程安全的</span></li><ul><li>.append()</li><li>.deleteCharAt()</li><li>.setCharAt()</li><li>.insert()</li><li>.reverse()</li></ul></ul><li>手动释放无用的引用对象<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>把你的方法分成几个part，确定一下哪些part运行时间长，然后把其他part无关的引用对象手动释放</span></li><li>缓冲经常使用的对象</li><li>尽量使用直接量<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>使用Byte, Short, Integer, Long, Float, Double, Boolen, Character包装类，不应该是用new来创建实例，应该采用直接量来创建它们。<br/>例如String str = &quot;hello&quot;;而不是String str = new String(&quot;hello&quot;);</span></li><li>少用静态变量</li><li>考虑使用SoftReference包装数组元素<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>要注意软引用的不确定。如果引用的为null，需要重新创建。</span></li><li>尽量不要使用finalize()方法</li></ul></ul></ul></ul></div></BODY></HTML>