<HTML><HEAD><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><style type="text/css">body {font-family: arial,sans-serif; font-size: 14pt; font-weight: normal; color: #000000;}h1 {font-size: 28pt; font-weight: bold;}h2 {font-size: 20pt; font-weight: bold;}.note {font-size: 10pt; font-weight: normal; font-style: italic; color:gray;}</style><title>iThoughts</title></HEAD><BODY><div style="font-family: arial,sans-serif; font-size: 14pt; font-weight: normal; color: #000000;"><ul><li>文件和流</li><ul><li>File<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function: 创建实例对象（仅仅是对象，拥有路径名字符串）<br/><br/>Notice:File可能是目录（文件夹）也可能是文件，取决于mkdir() 或者 createNewFile()<br/><br/>            File里面的文件可以通过FileOutputStream的方式写入时  创建  ，而不用特意重新用createNewFile（）方法创建<br/><br/>            File文件在创建的时候会查询路径下是否有文件/路径相同，如果有的话，就不会创建出来</span></li><ul><li>Zip</li><ul><li>压缩单个文件<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>public static void ZipFile(String filepath ,String zippath) {<br/>    try {<br/>        File file = new File(filepath);<br/>        File zipFile = new File(zippath);<br/>        InputStream input = new FileInputStream(file);<br/>        ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile));<br/>        zipOut.putNextEntry(new ZipEntry(file.getName()));<br/>        int temp = 0;<br/>        while((temp = input.read()) != -1){<br/>            zipOut.write(temp);<br/>        }<br/>        input.close();<br/>        zipOut.close();<br/>    } catch (Exception e) {<br/>        e.printStackTrace();<br/>    }<br/>}</span></li><li>压缩单个文件夹<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>public static void ZipMultiFile(String filepath ,String zippath) {<br/>    try {<br/>        File file = new File(filepath);// 要被压缩的文件夹<br/>        File zipFile = new File(zippath);<br/>        InputStream input = null;<br/>        ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile));<br/>        if(file.isDirectory()){<br/>            File[] files = file.listFiles();<br/>            for(int i = 0; i &lt; files.length; ++i){<br/>                input = new FileInputStream(files[i]);<br/>                zipOut.putNextEntry(new ZipEntry(file.getName() + File.separator + files[i].getName()));<br/>                int temp = 0;<br/>                while((temp = input.read()) != -1){<br/>                    zipOut.write(temp);<br/>                }<br/>                input.close();<br/>            }<br/>        }<br/>        zipOut.close();<br/>    } catch (Exception e) {<br/>        e.printStackTrace();<br/>    }<br/>}</span></li></ul><li>Delete</li><ul><li>删除服务器上的文件<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>public static void DeleteFile(File file){<br/>       File[] fileArray = file.listFiles();<br/>       if (fileArray.length &gt; 0){<br/>           for (int i = 0; i&lt; fileArray.length; i++){<br/>               if(fileArray[i].isFile())<br/>                   if(fileArray[i].delete()){<br/>                       System.out.println(&quot;Delete Successfully&quot; + &quot; in: &quot; + fileArray[i].getAbsolutePath());<br/>                   }else {<br/>                       System.out.println(&quot;Delete False&quot; + &quot; in: &quot; + fileArray[i].getAbsolutePath());<br/>                   }<br/>               else{<br/>                   DeleteFile(fileArray[i]);<br/>               }<br/>           }<br/>       }<br/>      if (file.delete()){<br/>          System.out.println(&quot;Delete Successfully&quot; + &quot; in: &quot; + file.getAbsolutePath());<br/>      }else{<br/>          System.out.println(&quot;Delete False&quot; + &quot; in: &quot; + file.getAbsolutePath());<br/>      }<br/>}</span></li></ul><li>.mkdir()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function:只能创建单个目录（文件夹）<br/><br/>Notice:如果在不存在的路径下创建多个目录（文件夹），将会false，并且不创建，不会报错</span></li><li>.mkdirs()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function:能创建多个目录（文件夹）<br/><br/>Notice:如果在不存在的路径下创建多个目录（文件夹），将会成功，并且自动创建多个目录（文件夹）</span></li><li>.createNewFile()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function:创建一个文件<br/><br/>Notice:强制在不存在的路径下（目录/文件夹）下创建文件，会报错“系统找不到指定路径”</span></li><li>.exists()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function:是否存在一系列的文件路径</span></li><li>.isFile()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function: 是否存在这个文件</span></li><li>.isDirectory()</li><li>.listFiles()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function: 文件下的所有文件list集合<br/><br/>File[] files = file.listFiles();</span></li><li>File.separator<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function:文件路径分隔符</span></li></ul><li>Path</li><ul><li>HttpServeletRequest request</li><ul><li>getSession()</li><ul><li>getServletContest()</li><ul><li>getRealPath(&quot;/&quot;)<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function:获取服务器根路径(wabapp)目录</span></li></ul></ul></ul><li>\\</li><li>file.getAbsolutePath()<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function:获取当前文件的绝对路径</span></li><li>file.getCanonicalPath()</li><li>file.getPath()</li></ul><li>OutputStream<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function: 对文件字节流的write，字节流输入<br/><br/>File toFile = new File(toPath);<br/>OutputStream os = new FileOutputStream(toFile);<br/>BufferedOutputStream bos = new BufferedOutputStream(os);<br/><br/>bos.write(b);<br/>bos.close();</span></li><ul><li>FileOutputStream<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>FileOutputStream(File file)<br/>Creates a file output stream to write to the file represented by the specified File object.<br/><br/>FileOutputStream(File file, boolean append)<br/>Creates a file output stream to write to the file represented by the specified File object.<br/><br/>FileOutputStream(FileDescriptor fdObj)<br/>Creates a file output stream to write to the specified file descriptor, which represents an existing connection to an actual file in the file system.<br/><br/>FileOutputStream(String name)<br/>Creates a file output stream to write to the file with the specified name.<br/><br/>FileOutputStream(String name, boolean append)<br/>Creates a file output stream to write to the file with the specified name.</span></li><li>BufferedOutStream<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function: 缓冲作用，缓冲区<br/><br/>File toFile = new File(toPath);<br/><br/>OutputStream os = new FileOutputStream(toFile);      <br/>or     OutputStream toCline = new BufferedOutputStream(response.getOutputStream());<br/><br/>BufferedOutputStream bos = new BufferedOutputStream(os); </span></li></ul><li>InputStream<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function: 对文件进行read，字节流的输出<br/><br/>File fromFile = new File(fromPath);<br/>InputStream is = new FileInputStream(fromFile);<br/>BufferedInputStream bis = new BufferedInputStream(is);<br/><br/>byte b[] = new byte[(int)fromFile.length()] ;<br/>or  <br/>while(bis.read(b, 0, b.length) != -1)bos.write(b, 0, b.length);         //一个一个字节读<br/><br/>bis.read(b);<br/>bis.close(); </span></li><ul><li>FileInputStream<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>public FileInputStream(String name)<br/><br/>public FileInputStream(File file)<br/><br/>public FileInputStream(FileDescriptor fdObj)</span></li><li>BufferedInputStream<span style="font-size: 10pt; font-weight: normal; font-style: italic; color:gray;"><br/>Function: 缓冲作用，缓冲区<br/><br/>InputStream fis = new BufferedInputStream(new FileInputStream(String path));<br/><br/>File  fromFile = new File(fromPath);<br/>InputStream is = new FileInputStream(fromFile);<br/>BufferedInputStream bis = new BufferedInputStream(is);</span></li></ul></ul></ul></div></BODY></HTML>